## 绪论
### 问题和算法
- 算法（Algorithm）是问题求解过程的精确描述，具有如下性质：
    - 有穷性（描述的有穷性）：由有限条“指令”或“语句”构成
    - 能行性：指令（语句）含义简单明确，其过程可以完全机械地进行
    - 确定性：作用于所求解问题的给定输入（要处理的问题实例的某种描述），将产生出唯一的确定的动作序列
    - 终止性（行为的有穷性）：产生的动作序列有穷，它或终止并给出问题的解；或终止并指出对给定的输入本问题无解
    - 输入/输出：有确定的输入和输出
### 大O表示法
- 定义：如果存在两个正常数c和n0，当实例的规模n≥n0后，某算法的时间（或者空间）代价T(n)≤c·f(n)（或S(n)≤c·f(n)），则说该算法的时间代价（或者空间代价）为O(f(n)) 
    - 朴素的解释：当实例的规模n充分大时，该算法所需时间（空间）不大于f(n)的某个常数倍
    - 也说该算法的时间（或空间）代价的增长率为f(n)
### 数据结构
- 一种数据结构是采用一套特定方式建立起来的一种数据组织结构
- 特征：
    - 逻辑结构：数据元素之间有某种特定的逻辑关系
        - 集合结构、线性结构、树形结构、图结构
    - 物理结构：数据的逻辑结构在计算机存储器中的映射（或表示），又称存储结构，或数据结构的存储表示
    - 行为特征：作用于数据结构上的各种运算。例如检索元素、插入元素、删除元素等一般性操作，还可能有一些特殊操作

## 抽象数据类型和Python类

## 数据结构的公共操作
- 作用上看：
    - 构造：构造出一个新实例
    - 访问：从已有数据结构中提取某些信息，但不创建新结构，也不修改被操作的结构
    - 变动：修改已有的结构
- 支持操作类型：
    - 不变
    - 变动


## 线性表
- 一种元素集合，其中还记录着元素间的一种顺序关系。
- 实现模型：顺序表和链接表
### 顺序表
- 元素顺序存放在一片足够大的连续存储区内，表中首元素存入存储区的开始位置，其余元素依次顺序存放
- 地址计算公式：$Location(e_i)=Location(e_0)+ci$，其中c是一个元素的存储量
#### 操作
- 访问第i个元素：O(1)
- 表空、表满：O(1)
- 查找给定元素的位置：通过循环，和表内元素逐个比较
- 尾端加入、删除：O(1)
- 首端（定位）加入：不要求保序：O(1)；要求保序：O(n)
- 加入操作平均移动次数：$\sum_{i=0}^{n}(n-i) p_{i}$
- 删除操作平均移动次数：$\sum_{i=0}^{n-1}(n-i-1)p_i^{\prime}$
#### 优缺点
- 优点：
    - O(1) 时间（随机，直接）按位置存取元素
    - 元素存储紧凑，除表元素存储外只需 O(1)空间存放辅助信息
- 缺点：
    - 需要连续的大块存储区存放表中的元素，可能有大量空闲单元
    - 加入删除操作时通常要移动许多元素
    - 需要考虑元素存储区的大小（有时事先很难估计）
#### 顺序表的实现
- 一体式实现
- 分离式实现
    - 优点：可以根据需要换一块元素存储，扩大容量
    - 表满时：
        - 申请一块更大的元素存储区
        - 把表中已有的元素拷贝到新存储区
        - 改变表对象的元素区链接
        - 实际加入新元素
    - 常量增长策略：O(n^2)
    - 比例增长策略：O(n)
#### Python中list的实现
- append:O(1)
- len:O(1)
- 不是尾端加入、切片替换、切片删除、表拼接：O(n)
### 链接表
#### 优点与缺点
- 优点：
    - 表结构是通过一些链接起来的结点形成的，结构很容易调整修改
    - 不修改结点里的数据元素，只通过修改链接，就能灵活地修改表的结构和内容。如加入/删除一个或多个元素，翻转整个表，重排元素的顺序，将一个表分解为两个或多个等
    - 整个表由一些小存储块构成，较容易安排和管理
- 缺点：
    - 一些操作的开销大：基于位置找到表中元素需要线性时间
    - 尾端操作需要线性时间（增加尾指针可以将尾端加入元素变为常量操作，但仍不能有效实现尾端删除）
    - 找当前元素的前一元素需要从头扫描表元素（双链表可以解决这个问题，但每个结点要付出更多存储代价），应尽量避免
#### 结点类及操作


```python
class LNode:
    def __init__(self,elem,next_=None):
        self.elem=elem
        self.next=next_

pnode=LNode(1)
for i in range(2,11):
    pnode.next=LNode(i)
    pnode=pnode.next
    print(pnode.elem)
```

    2
    3
    4
    5
    6
    7
    8
    9
    10


#### 单链表基本操作
- 创建空链表：把表头变量设置为空链接（Python中设置为None）
- 删除：Python里将表指针设置为None
- 判断表是否为空：表头变量的值和空链接比较
- 链接表不会满
- 复杂性：
    - 基本操作：
        - 创建空表：O(1)
        - 删除表：在 Python 里是 O(1)。当然存储管理也需要时间
        - 判断空表：O(1)
    - 加入元素（都需要加一个 T(分配) 的时间）：
        - 首端加入元素：O(1)
        - 尾端加入元素：O(n)，因为需要找到表的最后结点
        - 定位加入元素：O(n)，平均情况和最坏情况
    - 删除元素：
        - 首端删除元素：O(1)；尾端删除：O(n)
        - 定位删除元素：O(n)，平均情况和最坏情况
        - 其它删除通常需要扫描整个表或其一部分，O(n)
    - 其他：
        - 求长度、遍历：O(n)


```python
class LinkedListUnderflow(ValueError):
    pass
class LList:
    def __init__(self):
        self._head=None
    def is_empty(self):
        return self._head is None
    def prepend(self,elem):
        self._head=LNode(elem,self._head)#LNode要标明链接
    def append(self,elem):
        if self._head is None:
            self._head=LNode(elem)
        p=self._head
        while p.next is not None:
            p=p.next
        p.next=LNode(elem)#这一行不能放在while循环里
    def popfirst(self):
        if self._head is None:
            raise LinkedListUnderflow('in popfirst')
        else:
            e=self._head.elem
            self._head=self._head.next
            return e
    def poplast(self):
        if self._head is None:
            raise LinkedListUnderflow('in poplast')
        else:
            p=self._head
            if self._head.next is None:#表中只有一个元素
                e=self._head.elem
                self._head=None
                return e
            while p.next.next is not None:#找到了倒数第二个
                p=p.next
            e=p.next.elem
            p.next=None
            return e
    def printall(self):
        p=self._head
        while p is not None:#这里不能写成while p.next !=None，否则就不会输出最后一个结点
            print(p.elem)
            p=p.next
test=LList()
test.is_empty()
test.prepend(1)
test.append(10)
test.append(20)
test.popfirst()
test.poplast()
test.printall()
```

    10


#### 链接表的变形
##### 带尾节点引用的单链表
- 头结点的next直接指向尾节点


```python
class LList_tail(LList):
    def __init__(self):
        LList.__init__(self)
        self.rear=None
    def append(self,elem):
        if self._head is None:
            self._head=LNode(elem,self._head)
            self.rear=self._head
        else:
            self.rear.next=LNode(elem)
            self.rear=self.rear.next
test2=LList_tail()
test2.append(10)
test2.append(20)
test2.append(30)
test2.printall()
```

    10
    20
    30


##### 循环单链表
- 让表对象指向概念上的尾结点更有利


```python
class LClist:
    def __init__(self):
        self._rear=None
    def is_empty(self):
        return self._rear is None
    def prepend(self,elem):
        p=LNode(elem)
        if self._rear is None:
            p.next=p
            self._rear=p
        else:
            p.next=self._rear.next
            self._rear.next=p
    def append(self,elem):
        p=LNode(elem)
        if self._rear is None:
            p.next=p
            self._rear=p
        else:
            p.next=self._rear.next
            self._rear.next=p
            self._rear=self._rear.next
    def pop(self):
        if self._rear is None:
            raise LinkedListUnderflow('in pop of CLList')
        p=self._rear.next
        if self._rear is p:
            self._rear=None
        else:
            self._rear.next=p.next
        return p.elem
    def printall(self):
        if self.is_empty():
            return
        else:
            p=self._rear.next
            while True:
                print(p.elem)
                if p is self._rear:
                    break
                p=p.next
mlist=LClist()
mlist.append(3)
mlist.append(4)
mlist.prepend(1)
mlist.prepend(2)
mlist.append(5)
mlist.printall()
```

    2
    1
    3
    4
    5


##### 双链表
- 需要延伸结点类，增加指向前面的链接



```python
class LDNode(LNode):
    def __init__(self,elem,prev=None,next_=None):
        LNode.__init__(self,elem,next_)
        self.prev=prev
class LDList(LList_tail):
    def __init__(self):
        LList_tail.__init__(self)
    def rev(self):
        p=None
        while self._head is not None:
            q=self._head
            self._head=q.next
            q.next=p
            p=q
        self._head=p
r=LDList()
r.append(10)
r.append(20)
r.append(30)
r.append(40)
r.printall()
r.rev()
r.printall()
```

    10
    20
    30
    40
    40
    30
    20
    10


#### 总结
- 单链表只有一个方向的链接，支持O(1)的前端插入和删除，定位操作或尾端操作都需要O(n)时间。
- 增加了尾结点引用的单链表可很好支持首端/尾端插入和首端弹出，都是O(1)时间复杂度的操作，但不能支持高效的尾端删除
- 循环单链表支持高效首端/尾端插入和首端弹出，扫描需注意结束判断
- 双链表中结点有两个方向的链接，能高效找到前后结点。有尾结点引用时两端插入和删除都是O(1)时间操作。
- 单链表的遍历和检索只能从表头开始，需O(n)时间。双链表的这些操作可从表头或表尾开始，复杂度不变。与它们对应的循环链表，遍历和检索可以从表中任何一个地方开始，但要注意结束条件

#### 表的应用
- 约瑟夫问题的顺序表算法和循环链表算法


```python
class Josephus(LClist):
    def turn(self,m):
        for i in range(m):
            self._rear=self._rear.next
            #新方法，沿next方向移动m步
    def __init__(self,n,k,m):
        LClist.__init__(self)
        for i in range(n):
            self.append(i+1)
        self.turn(k-1)
        while not self.is_empty():
            self.turn(m-1)
            print(self.pop())
J=Josephus(10,3,2)
```

    4
    6
    8
    10
    2
    5
    9
    3
    1
    7


## 字符串
### 概念
- 字符串是特殊的线性表，表中元素选自选定字符集
- 字符集是有穷的一组字符构成的集合
- 称s1为s2的一个子串，如果存在两个串s和s'使下式成立:s2 = s + s1 + s'
- 如果s1是s2的子串，也说s1在s2里出现，称s2里与s1相同的字符段的第一个字符的位置为：s1在s2里出现的位置
### Python字符串
- 一体式的连续形式
### 字符串匹配
- 模式串长小于目标串
#### 朴素的串匹配算法
- 时间复杂度：O(mn)
- 效率低的原因：每次都看作完全独立的操作；回溯
- 通配符(？，*)与正则表达式（顺序组合，选择组合|，星号）


```python
def naivematch(pattern,target):
    p=len(pattern)
    t=len(target)
    i=0#这里一定要先声明
    j=0
    while i<p and j<t:
        if pattern[i]==target[j]:
            i=i+1
            j=j+1
        else:
            j=j-i+1
            i=0
    if i==p:#比较已经比较到了pattern的最后一位
        return j-i#应该返回target串能匹配上的首下标，而不是最后一个刚刚比较完的下标
naivematch('abc','shdlabc')
```




    4



## 栈
- 可以看作只在一端插入和删除的表
- LIFO
- 采用顺序表方式实现，在后端插入删除都是O(1)操作
- 采用链接表方式实现，在前端插入删除都是O(1)操作


```python
class StackUnderflow(ValueError):
    pass
class SStack:#顺序表实现
    def __init__(self):
        self._elems=[]
    def is_empty(self):
        return self._elems==[]
    def top(self):
        if self._elems==[]:
            raise StackUnderflow('in top')
        else:
            return self._elems[-1]
    def push(self,elem):
        self._elems.append(elem)
    def pop(self):
        if self._elems==[]:
            raise StackUnderflow('in pop')
        else:
            return self._elems.pop()
        
class LStack:
    def __init__(self):
        self._top=None
    def is_empty(self):
        return self._top is None
    def top(self):
        if self._top is None:
            raise StackUnderflow('in top')
        else:
            return self._top.elem
    def push(self,elem):
        self._top.next=LNode(elem)
    def pop(self):
        if self._top==None:
            raise StackUnderflow('in pop')
        else:
            p=self._top
            self._top=p.next
            return p.elem

```

### 栈的应用
#### 括号配对问题
- 顺序检查字符串字符
- 遇到开括号将其压入一个栈
- 遇到闭括号弹出栈顶元素与其匹配


```python
def paresmatch(text):
    open_pares='([{'
    close_pares=')]}'
    pair={')':'(',']':'[','}':'{'}
    st=SStack()
    try:
        for i in range(len(text)):
            if text[i] in open_pares:
                st.push(text[i])
            elif text[i] in close_pares:
                if st.pop()!=pair[text[i]]:
                    print('Unmatch!')
                    return False
                else:
                    print('Success!')
                    return True
    except:
        print('Unmatch!')
        return False
print(paresmatch('[abc]'))
print(paresmatch('([c)'))
```

    Success!
    True
    Unmatch!
    False


#### 表达式的表示、计算和变换
##### 后缀表达式的计算
- 不是运算符就压入栈
- 是运算符就弹出最近的两个数
- 计算之后再压入栈
- 下面的程序没有考虑栈深和其他的错误


```python
def cal(exp):
    st=SStack()
    oper='+-*/'
    for i in range(len(exp)):
        if not exp[i] in oper:
            st.push(float(exp[i]))#这一步是必要的，否则就变成了字符串拼接
        elif exp[i] in oper:
            a=st.pop()
            b=st.pop()
            if exp[i] =='+':
                c=a+b
            elif exp[i]=='-':
                c=a-b
            elif exp[i]=='*':
                c=a*b
            elif exp[i]=='/':
                c=a/b
            st.push(c)
    return st.pop()
cal('12+4*')
```




    12.0



##### 中缀表达式到后缀表达式的转换
- 遇到运算对象应直接输出（因为运算符应该在它们的后面）
- 需要考虑中缀运算符的优先级，适时输出 
- 遇到运算符时不能直接输出，只有下一运算符的优先级不高于本运算符时，才应该做本运算符要求的计算
### 栈与函数调用
- 可以证明：任何递归定义的函数（程序），都可以通过引入一个栈保存中间结果，翻译为一个非递归的过程。与此对应，任何一个包含循环的程序都可翻译为一个不包含循环的递归程序。这两个翻译过程都可计算，可以写出完成这两种翻译的程序，把任何递归定义的函数翻译到完成同样工作的非递归的函数，或者把任何包含循环的程序翻译为不包含循环的递归程序


```python
def knap(weight,wlist,n):
    if weight==0:
        return True
    elif weight<0 or (weight>0 and n<1):
        return False
    elif knap(weight-wlist[n-1],wlist,n-1):
        print(n,wlist[n-1])
        return True
    elif knap(weight,wlist,n-1):
        return True
    else:
        return False
knap(10,[1,2,3,4,2],3)
```




    False



## 队列
- 可看作只在一端插入另一端访问和删除的表
- FIFO
### 队列的链接表实现
- 只需用带尾结点的单链表
### 队列的顺序表实现
- 总会有入队/出队其中之一是O(n)
- 记住队头，会导致前面有浪费的空余
- 环形队列


```python
class SQueue:
    def __init__(self,init_len=8):
        self._len=init_len
        self._elems=[0]*init_len
        self._head=0
        self._num=0
    def is_empty(self):
        return self._num==0
    def peek(self):
        if self._num==0:
            raise QueueUnderflow
        return self._elems[self._head]
    def dequeue(self):
        if self._num==0:
            raise QueueUnderflow
        e=self._elems[self._head]
        self._head=(self._head+1)%self._len
        self._num=self._num-1
        return e
    def enqueue(self,elem):
        if self._num==self._len:
            self.__extend()
        self._elems[(self._head+self._num)%self._len]=e
        self._num=self._num+1
    def __extend(self):
        old_len=self._len
        self._len=self._len*2
        new_elems=[0]*self._len
        for i in range(old_len):
            new_elems[i]=self._elems[(self._head+i)%old_len]
        self._elems=new_elems
        self._head=0
```



## 二叉树与树
### 概念
- 有序树和无序树
- 一个结点的子节点个数成为该结点的度数
- 结点都有层数，根在0层，子结点的层数比其父结点大1
- 二叉树：
    - 结点的有限集合，集合或为空集，或由一个根节点和两棵不相交的二叉树组成
    - 左子树和右子树
    - 是与树不同的结构，不是特殊情况
    - 满二叉树：树中每个分支结点都有两棵非空子树
    - 完全二叉树：除最下两层外，其余结点度数都是2（显然都不是叶结点），如果最下一层的结点不满，则所有空位都在在右边，左边没有空位
    - 扩充二叉树（由已有非空二叉树生成的一种二叉树）：原二叉树的最小结点扩充，使原树中所有结点的度数都变成2，扩充结点的个数比原树结点的个数多1
### 性质
- 二叉树性质：
    - 性质1 非空二叉树第$i$层上至多有$ 2i $个结点
    - 性质2 高度为$ k $的二叉树至多有$ 2k-1 $个结点
    - 性质3 对任何非空二叉树，若其叶结点个数为$n_0$，度数为2的结点个数为$n_2$，则$n_0 = n_2 + 1$
    - 性质4 $n$个结点的完全二叉树的高度$k = \lceil log_2(n+1)\rceil$
    - 性质5 满二叉树里的叶结点比分支结点多一个
    - 性质6 （完全二叉树）如果$ n $个结点的完全二叉树的结点按层次并从左到右的顺序从 0 开始编号，对任一结点$ i（0 ≤ i ≤ n-1) $都有：
        - 序号 0 的结点是根
        - 对于$ i > 0$，其父结点是$\lfloor (i - 1)/2\rfloor$
        - 若 $2i + 1 ≤ n$，其左子结点序号为$2  i + 1$；否则它无左子结点
        - 若 $2  i + 2 ≤ n$，其右子结点序号为$2  i + 2$；否则它无右子结点

### 二叉树的类实现
- 如果知道一棵二叉树的中根序列，又知道先根/后根序列，就可以唯一确定这个二叉树
- 先根序遍历的平均空间复杂性是O(logn),关键是栈中最大深度（遍历的二叉树高度）。
- 时间复杂性是O(n)


### 优先队列
- 特点是存入优先队列的每项数据都有一个优先级，保证任何时候访问或弹出的总是当时所存元素中最优先的
- 顺序表实现，总会在插入和取出元素的时候有一种是O(n)的复杂度
#### 堆
- 一个堆在结构上是一棵在结点里存储数据的完全二叉树
- 去掉一个堆的最后元素，剩下的仍是堆
- 一个堆去掉堆顶，其余元素形成两个堆
- 给按上面方式得到的两个堆加一个元素作为根，得到一棵完全二叉树但未必是堆
- 在一个堆的最后加上一个元素，整个结构是一棵完全二叉树，但未必是堆
- 操作：加入一个元素，把加入后得到的完全二叉树转变为堆/弹出最小元素后，如何将剩下的元素重新做成堆：复杂度：O(n)
##### 实现
- 向上筛选：新加入的结点与其父结点比较，如果新加入的较小就交换
- 向下筛选：用e与B、C的顶元素（根）比，最小者作为整个堆的顶。



```python
class PrioQueue:
    def __init__(self,elist=[]):
        self.elems=list(elist)
        if elist!=[]:
            self.buildheap()
    def is_empty(self):
        return self.elem==[]
    def peek(self):
        if self.is_empty():
            raise PrioQueueError('in top')
        return self.elems[0]
    def enqueue(self,e):
        self.elems.append(None)
        self.siftup(e,len(self.elems)-1)
    def siftup(self,e,last):
        elems=self.elems
        i=last
        j=(last-1)//2
        while i>0 and e<elems[j]:
            elems[i]=elems[j]
            i=j
            j=(j-1)//2
        elems[i]=e
    def dequeue(self):
        if self.is_empty():
            raise PrioQueueError('in pop')
        elems=self.elems
        e0=elems[0]
        e=elems.pop()
        if len(elems)>0:
            self.siftdown(e,0,len(elems))
        return e0
    def siftdown(self,e,begin,end):
        elems=self.elems
        i=begin
        j=begin*2+1
        while j<end:
            if j+1<end and elems[j+1]<elems[j]:
                j=j+1
            if e<elems[j]:
                break
            elems[i]=elems[j]
            i=j
            j=2*j+1
        elems[i]=e
    def buildheap(self):
        end=len(self.elems)
        for i in range(end//2,-1,-1):
            self.siftdown(self.elems[i],i,end)#?
```

##### 堆排序
- 时间复杂性是O(nlogn)，空间是O(1)



```python
def heap_sort(elems):
    end=len(elems)
    for i in range(end//2,-1,-1):
        siftdown(elems,elems[i],i,end)
    for i in range((end-1),0,-1):
        e=elems[i]
        elems[i]=elems[0]
        PrioQueue.siftdown(elems,e,0,i)#?
```

### 哈夫曼树
- 重复以下步骤，直到只剩一棵树为止：
    - 从F选取两棵权最小的树作为左右子树，构造一棵新二叉树，设置其根节点权值为两棵子树的根结点的权值之和
    - 从F删除所选的两棵树，把新构造的二叉树加入F
#### 哈夫曼编码
- 构造一棵哈夫曼树，在得到的哈夫曼树中，给所有从一个结点到其左子结点的边标上二进制数字0；引向其右子结点的边标上1
- 以从根结点到一个叶结点的路径上的二进制数字序列，作为这个叶结点的字符的编码。这就是哈夫曼编码

### 树与树林
- 从树、树林转换为二叉树的步骤： 
    - 对于相邻的兄弟结点，从左到右，从前一子结点和后一子结点连一条边（对树林，相邻树的根之间也同样连一条边）
    - 对每个非叶结点，只保留从它到其最左子结点的边，删去它到它的其它子女的边
- 从二叉树转换到树林：
    - 如果某结点是其父结点的左子树，则将其向右的路径上的各个结点作为其父结点的顺序的各个子结点
    - 去掉原二叉树中各结点到其右子结点的连线
#### 表示
- 子结点引用表示
- 父结点引用表示
- 子表表示

## 图
- 一个图是一个二元组G=(V,E)
- 有向图用尖括号表示，无向图用圆括号表示
- 两个限制：不考虑顶点到自身的边、顶点间没有重复出现的边
- 完全图：任意两顶点间都有边的图
- 度：与一个顶点邻接的边的条数。
$$
e=\frac{1}{2}\sum_{i=1}^n D(v_i)
$$
- 回路：起点和终点相同的路径。如果除起点和终点以外其他顶点均不相同，称为简单回路
- 简单路径：内部不包含回路的路径
- 有根图：如果在有向图G里存在一个顶点v，从v到图G中其他每个顶点均有路径，则称G为一个有根图。
    - 包含n个顶点的最小有根图恰好包含n-1条边
- 连通图：
    - 无向图：G中任意两个不同顶点之间都连通。包含n个顶点的最小连通无向图恰有n-1条边
    - 有向图：注意路径有方向
- 带权的连通无向图称为网络
### 表示方法
#### 邻接矩阵表示法
- 无向图的邻接矩阵表示是一个对称矩阵
- 缺点：空间复杂性和结点数的平方成正比
#### 邻接表表示法
- 每个顶点的邻接边用一个（不一定等长的）list 表示，元素形式 为(vj,w)，vj是边的终点，w是边的信息（权或者1）


```python
class Graph:
    def __init__(self,mat,unconn=0):
        vnum=len(mat)
        for x in mat:
            if len(x)!=vnum:
                raise ValueError('Argument for Graph')
        #self._mat=[mat[i][:] for i in range(vnum)]
        self._unconn=unconn
        self._vnum=vnum
        self._mat=[]
        for i in range(vnum):
            edges=[]
            for j in range(len(mat[i])):
                if mat[i][j]!=unconn:
                    edges.append((j,mat[i][j]))
            self._mat.append(edges)
            
    def _invalid(self,v):
        return 0>v or v>=self._vnum
    def vertex_num(self):
        return self._vnum
    def add_vertex(self):
        self._mat.append([])
        self._vnum=self._vnum+1
        return self._vnum-1
    def add_edge(self,vi,vj,val=1):
        if self._vnum==0:
            raise GraphError('Cannot add edge to empty graph')
        if self._invalid(vi) or self._invalid(vj):
            raise GraphError(str(vi)+'or'+str(vj)+'is not valid vertex')
        row=self._mat[vi]
        i=0
        while i<len(row):
            if row[i][0]==vj:
                self._mat[vi][i]=(vj,val)
                return
            if row[i][0]>vj:
                break
            i=i+1
        self._mat[vi].insert(i,(vj,val))
    def get_edge(self,vi,vj):
        if self._invalid(vi) or self._invalid(vj):
            raise GraphError(str(vi)+'or'+str(vj)+'is not a valid vertex')
        for i, val in self._mat[vi]:
            if i==vj:
                return val
        return self._unconn
    def out_edges(self,vi):
        if self._invalid(vi):
            raise GraphError(str(vi)+'is not a valid vertex')
        return self._mat[vi]
G=Graph([[0,1,1,0],[1,0,0,1],[1,0,0,0],[0,1,0,0]])
print(G.vertex_num())
print(G._mat)
print(G.get_edge(1,1))
print(G.out_edges(2))                  
```

    4
    [[(1, 1), (2, 1)], [(0, 1), (3, 1)], [(0, 1)], [(1, 1)]]
    0
    [(0, 1)]


### 基本图算法
#### 遍历
##### 深度优先遍历
- 从指定顶点v出发，先访问v（并将其标记为已访问）
- 从v的未访问过的邻接顶点出发进行深度优先搜索（邻接顶点可能排定一种顺序），直到与v连通的所有顶点都已访问（递归）
- 如果图中还存在未访问顶点，则选出一个未访问顶点，由它出发重复前述过程，直到图中所有顶点都已访问为止
###### 非递归算法


```python
def DFS(graph,v0):
    vnum=graph.vertex_num()
    visited=[0]*vnum
    seq=[v0]
    visited[0]=1
    st=SStack()
    st.push((0,graph.out_edges(v0)))
    while not st.is_empty():
        i,edges=st.pop()
        if i<len(edges):
            v,e=edges[i]
            st.push((i+1,edges))
            if not visited[v]:
                seq.append(v)
                visited[v]=1
                st.push((0,graph.out_edges(v)))
    return seq
DFS(G,0)
#Q
```




    [0, 1, 3, 2]



###### 生成树概念
- 从连通无向图或强连通有向图G的任一顶点v0出发，或从有根有向图的根v0出发，存在到图中其它各结点的路径
###### 递归算法


```python
def DFS_span_tree(graph):
    vnum=graph.vertex_num()
    span_forest=[None]*vnum
    def dfs(graph,v):
        for u,w in graph.out_edges(v):
            if span_forest[u] is None:
                span_forest[u]=(u,w)
                dfs(graph,u)
    for v in range(vnum):
        if span_forest[v] is None:
            span_forest[v]=(v,0)
            dfs(graph,v)
    return span_forest
DFS_span_tree(G)#?
```




    [(0, 0), (1, 1), (2, 1), (3, 1)]



##### 广度优先遍历
- 从指定顶点v出发，先访问v并将其标记为已访问
- 依次访问v的所有相邻顶点v1,v2,……,vm（可规定顺序），再依次访问与v1,v2,……,vm邻接的所有未访问顶点，直到访问完所有顶点
- 如果图中还存在未访问顶点，则选择一个未访问顶点，由它出发进行广度优先搜索，直到所有顶点都已访问为止

### 最小生成树
- 网络 G（带权连通无向图）的每条边带有一个给定的权值，它的一棵生成树中各条边的权值之和称为该生成树的权
- 网络 G 可能有多棵不同生成树，其权值可能不同。其中权值最小的生成树称为 G 的最小生成树
#### MST性质
- 设G=(V，E)是网络，U是V的任一真子集，e=(u,v)∈E且u∈U，v∈V-U，而且e在G中所有一个端点在U另一端点在V-U的边中权值最小，那么：G必有一棵包括边e的最小生成树
- 证明：取G的一棵最小生成树T（必定存在），若e属于T得证。否则将e加入T得到T'，由于T连通T'中必定有环。设环中另一条一端在 U另一端在V-U的边为e'。去掉e'得到另一生成树。由于e的定义，新生成树的权不大于T，即为所需。
#### Kruskal算法
- 按权排序
- 逐步加入最小权的边，观察是否能减少连通分量


```python
def Kruskal(graph):
    vnum=graph.vertex_num()
    reps=[i for i in range(vnum)]
    mst=[]
    edges=[]
    for vi in range(vnum):
        for v,w in graph.out_edges(vi):
            edges.append((w,(vi,v)))
    edges.sort()
    for w,e in edges:
        if reps[e[0]]!=reps[e[1]]:
            mst.append((e,w))
            if len(mst)==vnum-1:
                break
            rep,orep=reps[e[0]],reps[e[1]]
            for i in range(vnum):
                if reps[i]==orep:
                    reps[i]=rep
    return mst
Kruskal(G)#？
```




    [((0, 1), 1), ((0, 2), 1), ((1, 3), 1)]



#### Prim算法
- 初始把(0，0，0)放入优先队列，表示从顶点0到自身的长0的边
- 循环的第一次迭代把顶点0记入最小生成树顶点集U，方法是设 mst[0]=((0，0)，0)，同时把顶点0到其余顶点的边用权值作为优先数存入优先队列cands，表示待考察的候选边集合
- 执行中反复选择cands里记录的最短边(u,v)。如果v是V-U的顶点（该边连接U中顶点与V-U中顶点），就把该边及其权记入mst[v]，并把顶点v的出边存入cands；否则直接丢掉
- 结束时mst中是最小生成树的n条边，包括边(0,0)以方便实现


```python
def Prim(graph):
    vnum=graph.vertex_num()
    mst=[None]*vnum
    cands=PrioQueue([(0,0,0)])
    count=0
    while count<vnum and not cands.is_empty():
        w,u,v=cands.dequeue()
        if mst[v]:
            continue
        mst[v]=((u,v),w)
        count=count+1
        for vi,w in graph.out_edges(v):
            if not mst[vi]:
                cands.enqueue((w,v,vi))
    return mst
```

### 最短路径
#### Dijkstra算法



```python
def dijkstra(graph,v0):
    vnum=graph.vertex_num()
    assert 0<=v0<vnum
    paths=[None]*vnum
    count=0
    cands=PrioQueue([(0,v0,v0)])
    while count<vnum and not cands.is_empty():
        plen,u,vmin=cands.dequeue()
        if paths[vmin]:
            continue
        paths[vmin]=(u,plen)
        for v,w in graph.out_edges(vmin):
            if not paths[v]:
                cands.enqueue((plen+w,vmin,v))
        count=count+1
    return paths
```

## 字典
- 静态字典和动态字典
- 平均检索长度ASL：
$$
ASL=\sum_{i=0}^{n-1}p_ic_i
$$
### 关联


```python
class Assoc:
    def __init__(self,key,value):
        self.key=key
        self.value=value
    def __lt__(self,other):
        return self.key<other.key
    def __le__(self,other):
        return self.key<other.key or self.key==other.key
    def __str__(self):
        return 'Assoc({0},{1})'/format(self.key,self.value)
    
```

### 字典的顺序表实现
- 简单的顺序表缺点：平均检索长度大（删除依赖于检索）
#### 有序顺序表和二分检索
- 插入数据时需要保序：O(n)
- 删除时可以用二分检索，但是实际删除时需要移动数据：O(n)
- 检索时间：O(logn)
- 平均检索长度：
$$
\begin{aligned} A S L &=\frac{1}{n} *\left(\sum_{i=1}^{j} i * 2^{i-1}\right) \\ &=\frac{1}{n} * \sum_{i=1}^{j} \sum_{m=i}^{j} 2^{m-1} \\ &=\frac{1}{n} * \sum_{i=1}^{j}\left(2^{j}-2^{i-1}\right) \\ &=\frac{1}{n} *\left(j * 2^{j}-2^{j}+1\right) \\ &=\frac{n+1}{n} * \log _{2}(n+1)-1 \end{aligned}
$$
- 最大检索长度：$\lceil log_2(n+1)\rceil$


```python
def bisearch(lst,key):
    low=0
    high=len(lst)-1
    while low<=high:
        mid=(low+high)//2
        if key==lst[mid].key:
            return lst[mid].value
        if key<lst[mid].key:
            high=mid-1
        else:
            low=mid+1
            
bisearch([Assoc(1,2),Assoc(2,3),Assoc(3,4)],2)
```




    3



### 散列
- 关键码的映射
- 负载因子=散列表中实际元素个数/基本存储区能容纳的元素个数
- 除余法：整数关键码
    - 以关键码除以一个不大于散列表长度m的整数p得到的余数（或者余数加1）作为散列地址，p可以取小于m的最大素数
- 基数转换法：整数或字符串关键码
- 冲突消解问题
    - 内消解方法
    - 外消解方法

### 集合
- 无序：求交集的复杂性是O(mn)
- 按序排列，求交集/并集的复杂性为O(m+n)，但插入元素的复杂性变成了O(n)
#### 集合的位向量实现
- 如果所需要的集合对象有一个公共超集U
- 假定U包含n个元素，给每个元素一个编号作为该元素的“下标”。
- 对任何要考虑的集合S（注意 S⊆U），用一个n位的二进制序列 （位向量）vS表示S。对元素e∈U，如果e∈S，令vS里对应于 e（的编号，下标）的那个位取值1，否则令该位取值0
### 二叉排序树与字典
- 二叉排序树或者为空；或者是具有下列性质的二叉树：
    - 其根结点保存着一个数据项（及其关键码）
    - 如果其左子树不空，则其左子树中所有结点保存的（关键码）值均小于它的根结点保存的（关键码）值；
    - 如果其右子树不空，则其右子树中所有结点保存的（关键码）值均大于它的根结点保存的（关键码）值；
    - 左右子树（如果存在）也是二叉排序树
- 检索操作的空间复杂度：O(1)，检索时间开销：O(logn)
#### 插入
#### 删除
- q是叶结点，只需将其父结点p到q的引用置为None，删除完成
- q无左子结点，只需把q的右子树直接改作p的左子树
    - 删除之后，除了结点q已经不在，其余部分的顺序不变。 如果原来序列中的关键码递增，删除后也一样
- q有左子树，找到q左子树的最右结点，设为r，显然它无右子树
    - 用q的左子结点代替q作为p的左子结点 
    - 将q的右子树作为r的右子树

## 排序
### 简单排序算法
- 基本操作：
    - 比较关键码，确定序关系
    - 移动数据记录
- 评价标准
    - 执行时间
    - 所需要的附加空间
#### 插入排序
- 空间复杂性：只需要记录的辅助空间
- 时间复杂度：O(n^2)


```python
def naivesort(list1):
    for i in range(1,len(list1)):
        j=i
        while j>0 and list1[j-1]>list1[i]:
            list1[j]=list1[j-1]
            j=j-1
        list1[j]=list1[i]
    return list1
naivesort([1,2,5,6,2,5,3])#？
```




    [1, 2, 5, 6, 6, 6, 6]



#### 选择排序
- 用一个内层循环顺序比较，维护已发现的最小记录下标
- 循环结束时，找到未排序段的最小记录，交换到已排序段之后
- 未排序段剩下一个元素时就不必再选择（工作完成）
- 记录复制：最好 0（增加判断i=k时不交换），最坏 2×(n-1)
- 比较：n(n-1)/2
- 总的时间复杂度：O(n^2)
- 稳定性：不稳定
    - 找到最小元素后的直接交换，是导致不稳定的根源
    - 如果找到最小元素后，逐个后移k前面的尚未排序的元素，腾出未排序段最前位置后存入最小元素，得到的算法就是稳定的
    - 直接选择排序没有适应性，对任何序列都需要 O(n2) 次比较


```python
def select_sort(list2):
    for i in range(len(list2)-1):
        k=i
        for j in range(i,len(list2)):
            if list2[k]>list2[j]:
                k=j
        if i!=k:
            list2[i],list2[k]=list2[k],list2[i]
    return list2
select_sort([1,2,6,4,7,2])
```




    [1, 2, 2, 4, 6, 7]



#### 冒泡排序
- 通过交换逆序对实现排序的方法
- 比较相邻元素，遇到相邻的逆序对时交换它们
- 改进算法：
    - 用一个辅助变量，内循环开始时赋 False，遇到逆序赋True
    - 内层循环结束后检查这个变量，值为 False 就结束排序 
- 最坏时间复杂度为O(n^2)，平均时间复杂度也为O(n^2),辅助空间是 O(1)
- 起泡排序算法具有稳定性，相等元素不交换


```python
def bubble(list3):
    for i in range(len(list3)):
        for j in range(1,len(list3)-i):
            if list3[j-1]>list3[j]:#前后比较
                list3[j-1],list3[j]=list3[j],list3[j-1]
    return list3
bubble([1,2,4,6,3,6])
```




    [1, 2, 3, 4, 6, 6]



#### 快速排序
- 把被排序序列按某种标准分为大小两组，确定了两个元素组的顺序
- 而后采用同样方式递归地分别对两组记录排序
- 划分到每个子部分最多包含一个记录时，整个序列的排序完成

#### 归并排序
- 初始时把待排序的 n 个记录看成 n 个有序子序列，长度均为 1
- 把序列集合里的有序子序列两两归并，完成一遍，序列集合的规模减半，集合中的子序列长度加倍
- 重复上面操作，最终得到一个长度为 n 的有序序列

#### 分配排序

